<!DOCTYPE html>
<html lang="en">
  <head>
    <meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
    <meta content="utf-8" http-equiv="'encoding" />
  </head>

  <body>
    <canvas id="gameCanvas" width="800" height="600"></canvas>
  </body>
  <script>
    let carPic = document.createElement("img");
    let carPickLoaded = false;

    let carX = 75;
    let carY = 75;
    let carAng = 90;
    let carV = 0;

    const TRACK_W = 40;
    const TRACK_H = 40;
    const TRACK_GAP = 0;
    const TRACK_COLS = 20;
    const TRACK_ROWS = 15;

    //prettier-ignore
    let trackGrid = [
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1,
    1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1,
    1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1,
    1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1,
    1, 0, 2, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1,
    1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    
    ];

    let canvas, canvasContext;

    const KEY_LEFT_ARROW = 37;
    const KEY_UP_ARROW = 38;
    const KEY_RIGHT_ARROW = 39;
    const KEY_DOWN_ARROW = 40;

    let keyHeld_Gas = false;
    let keyHeld_Reverse = false;
    let keyHeld_Right = false;
    let keyHeld_Left = false;

    let mouseX = 0;
    let mouseY = 0;

    let updateMousePos = (evt) => {
      let rect = canvas.getBoundingClientRect();
      let root = document.documentElement;

      mouseX = evt.clientX - rect.left - root.scrollLeft;
      mouseY = evt.clientY - rect.top - root.scrollTop;
    };

    let keyPressed = (evt) => {
      if (evt.keyCode == KEY_LEFT_ARROW) {
        keyHeld_Left = true;
      }
      if (evt.keyCode == KEY_RIGHT_ARROW) {
        keyHeld_Right = true;
      }
      if (evt.keyCode == KEY_UP_ARROW) {
        keyHeld_Gas = true;
      }
      if (evt.keyCode == KEY_DOWN_ARROW) {
        keyHeld_Reverse = true;
      }

      evt.preventDefault();
    };

    let keyReleased = (evt) => {
      if (evt.keyCode == KEY_LEFT_ARROW) {
        keyHeld_Left = false;
      }
      if (evt.keyCode == KEY_RIGHT_ARROW) {
        keyHeld_Right = false;
      }
      if (evt.keyCode == KEY_UP_ARROW) {
        keyHeld_Gas = false;
      }
      if (evt.keyCode == KEY_DOWN_ARROW) {
        keyHeld_Reverse = false;
      }
    };

    window.onload = () => {
      canvas = document.getElementById("gameCanvas");
      canvasContext = canvas.getContext("2d");

      let fps = 30;
      setInterval(updateAll, 1000 / fps);

      canvas.addEventListener("mousemove", updateMousePos);

      document.addEventListener("keydown", keyPressed);
      document.addEventListener("keyup", keyReleased);

      carPic.onload = () => {
        carPickLoaded = true;
      };
      carPic.src = "f1Car.png";

      carReset();
    };

    let updateAll = () => {
      moveAll();
      drawAll();
    };

    let carReset = () => {
      for (let row = 0; row < TRACK_ROWS; row++) {
        for (let col = 0; col < TRACK_COLS; col++) {
          let arrayIndex = rowColToArrayIndex(col, row);
          if (trackGrid[arrayIndex] == 2) {
            trackGrid[arrayIndex] == 0;
            carAng = -Math.PI / 2;
            carX = col * TRACK_W + TRACK_W / 2;
            carY = row * TRACK_H + TRACK_H / 2;
          }
        }
      }
    };

    let carMove = () => {
      carV *= 0.98;
      if (keyHeld_Gas) {
        carV += 0.2;
      }
      if (keyHeld_Reverse) {
        carV -= 0.2;
      }
      if (keyHeld_Left) {
        carAng -= 0.08;
      }
      if (keyHeld_Right) {
        carAng += 0.08;
      }

      carX += Math.cos(carAng) * carV;
      carY += Math.sin(carAng) * carV;
    };

    let isTrackAtColRow = (col, row) => {
      if (col >= 0 && col < TRACK_COLS && row >= 0 && row < TRACK_ROWS) {
        let trackIndexUnderCoord = rowColToArrayIndex(col, row);
        return trackGrid[trackIndexUnderCoord] == 1;
      } else {
        return false;
      }
    };

    let carTrackHandling = () => {
      let carTrackCol = Math.floor(carX / TRACK_W);
      let carTrackRow = Math.floor(carY / TRACK_H);

      if (
        carTrackCol >= 0 &&
        carTrackCol < TRACK_COLS &&
        carTrackRow >= 0 &&
        carTrackRow < TRACK_ROWS
      ) {
        if (isTrackAtColRow(carTrackCol, carTrackRow)) {
          carX -= Math.cos(carAng) * carV;
          carY -= Math.sin(carAng) * carV;
          carV *= -0.5;
        }
      } //end of track found
    }; // end of valid col and row

    let moveAll = () => {
      carMove();

      carTrackHandling();
    };

    let rowColToArrayIndex = (col, row) => {
      return col + TRACK_COLS * row;
    };

    let drawTracks = () => {
      for (let row = 0; row < TRACK_ROWS; row++) {
        for (let col = 0; col < TRACK_COLS; col++) {
          let arrayIndex = rowColToArrayIndex(col, row);

          if (trackGrid[arrayIndex] == 1) {
            colorRect(
              TRACK_W * col,
              TRACK_H * row,
              TRACK_W - TRACK_GAP,
              TRACK_H - TRACK_GAP,
              "#1D7f07"
            );
          } // end of track test
        } // end of for loop
      }
    }; // end of func

    let drawAll = () => {
      colorRect(0, 0, canvas.width, canvas.height, "#3e3d3b"); //clear screen

      drawTracks();

      // colorCircle(carX, carY, 10, "white"); //draw car
      if (carPickLoaded) {
        drawBitmapCenteredWithRotation(carPic, carX, carY, carAng);
      }
    };

    let drawBitmapCenteredWithRotation = (useBitmap, atX, atY, withAng) => {
      canvasContext.save();
      canvasContext.translate(atX, atY);
      canvasContext.rotate(withAng);
      canvasContext.drawImage(
        useBitmap,
        -useBitmap.width / 2,
        -useBitmap.height / 2
      );
      canvasContext.restore();
    };

    let colorRect = (topLeftX, topLeftY, boxWidth, boxHeight, fillColor) => {
      canvasContext.fillStyle = fillColor;
      canvasContext.fillRect(topLeftX, topLeftY, boxWidth, boxHeight);
    };

    let colorCircle = (centerX, centerY, radius, fillColor) => {
      canvasContext.fillStyle = fillColor;
      canvasContext.beginPath();
      canvasContext.arc(centerX, centerY, radius, 0, Math.PI * 2, true);
      canvasContext.fill();
    };

    let colorText = (words, textX, textY, fillColor) => {
      canvasContext.fillStyle = fillColor;
      canvasContext.fillText(words, textX, textY);
    };
  </script>
</html>
